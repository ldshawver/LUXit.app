name: Deploy LUXit.app to VPS (main only)

on:
  push:
    branches:
      - main   # ONLY main deploys

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            # Hardened deploy script with rollback and diagnostics
            set -euxo pipefail

            # Configuration - edit to match your VPS/app
            APP_DIR="/opt/lux-marketing"
            VENV_PATH="venv"
            SERVICE_NAME="lux.service"
            HEALTH_URL="http://127.0.0.1:5000/"
            HEALTH_RETRIES=6        # number of attempts
            HEALTH_INTERVAL=5       # seconds between attempts
            DRY_RUN="${DRY_RUN:-false}"  # set to true to test without destructive actions

            echo "üì¶ Deploy started: user=$(whoami) host=$(hostname) pwd=$(pwd || true)"
            echo "üîí DRY_RUN=$DRY_RUN"

            # Simple concurrency protection
            LOCKFILE="/tmp/deploy_${SERVICE_NAME}.lock"
            if [ -e "$LOCKFILE" ]; then
              echo "‚ùå Deploy lock present ($LOCKFILE). Another deploy may be running. Aborting."
              exit 1
            fi
            trap 'rm -f "$LOCKFILE"' EXIT
            touch "$LOCKFILE"

            # Basic command availability checks
            for cmd in git python3 systemctl; do
              if ! command -v "$cmd" >/dev/null 2>&1; then
                echo "‚ùå Required command not found: $cmd"
                exit 1
              fi
            done

            if ! command -v curl >/dev/null 2>&1; then
              echo "‚ö†Ô∏è curl not found; health checks will be skipped"
              HAVE_CURL=false
            else
              HAVE_CURL=true
            fi

            # Ensure app directory exists
            if [ ! -d "$APP_DIR" ]; then
              echo "‚ùå App directory not found: $APP_DIR"
              ls -la "$(dirname "$APP_DIR")" || true
              exit 1
            fi
            cd "$APP_DIR"

            # Record previous commit so we can rollback
            PREV_COMMIT="$(git rev-parse --short HEAD || true)"
            echo "üîÅ Previous commit: ${PREV_COMMIT:-<none>}"

            # Fetch and update to origin/main
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would fetch and reset to origin/main"
            else
              git fetch origin --quiet
              # ensure branch exists locally
              if git rev-parse --verify main >/dev/null 2>&1; then
                git checkout main --quiet
              else
                git checkout -b main --track origin/main --quiet || true
              fi
              git reset --hard origin/main --quiet
            fi

            NEW_COMMIT="$(git rev-parse --short HEAD || true)"
            echo "‚úÖ New commit: ${NEW_COMMIT:-<none>}"

            if [ "$PREV_COMMIT" = "$NEW_COMMIT" ]; then
              echo "‚ÑπÔ∏è No changes between previous and new commit. Still running health check and sanity steps."
            fi

            # Show last commit info for diagnostics
            git --no-pager log -1 --oneline || true
            ls -la

            # Check virtualenv and activate
            if [ ! -f "${VENV_PATH}/bin/activate" ]; then
              echo "‚ùå virtualenv not found at ${VENV_PATH}/bin/activate"
              exit 1
            fi
            # shellcheck disable=SC1091
            source "${VENV_PATH}/bin/activate"

            # If requirements.txt changed between PREV and NEW, install deps
            NEED_PIP_INSTALL=false
            if [ -n "$PREV_COMMIT" ] && [ -n "$NEW_COMMIT" ] && [ "$PREV_COMMIT" != "$NEW_COMMIT" ]; then
              if git diff --name-only "$PREV_COMMIT" "$NEW_COMMIT" | grep -q -E '^requirements(\.txt)?$'; then
                NEED_PIP_INSTALL=true
              fi
            fi
            # If prev commit not known (first deploy), install anyway
            if [ -z "$PREV_COMMIT" ]; then
              NEED_PIP_INSTALL=true
            fi

            if [ "$NEED_PIP_INSTALL" = "true" ]; then
              echo "üì• Installing/upgrading dependencies (pip)"
              if [ "$DRY_RUN" = "true" ]; then
                echo "DRY-RUN: would run pip install -r requirements.txt"
              else
                if [ -f "requirements.txt" ]; then
                  pip install --upgrade pip setuptools wheel || true
                  pip install -r requirements.txt
                else
                  echo "‚ö†Ô∏è requirements.txt not present; skipping pip install"
                fi
              fi
            else
              echo "‚ÑπÔ∏è requirements.txt unchanged; skipping pip install"
            fi

            # Python compile checks (quick sanity)
            echo "üß™ Running Python compile checks"
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would run python -m py_compile"
            else
              python3 -m py_compile app.py || {
                echo "‚ùå Python syntax check failed"
                exit 1
              }
            fi

            # Helper: health check function
            check_health() {
              if [ "$HAVE_CURL" = "false" ]; then
                echo "‚ö†Ô∏è curl not available; skipping health check"
                return 0
              fi
              local i=0
              while [ $i -lt "$HEALTH_RETRIES" ]; do
                if timeout $HEALTH_INTERVAL curl -sSf "$HEALTH_URL" >/dev/null 2>&1; then
                  echo "‚úÖ Health check OK (attempt $((i+1)))"
                  return 0
                fi
                echo "‚è≥ Health check attempt $((i+1)) failed; waiting $HEALTH_INTERVALs before retry"
                i=$((i+1))
                sleep "$HEALTH_INTERVAL"
              done
              echo "‚ùå Health check failed after $HEALTH_RETRIES attempts"
              return 1
            }

            # Restart service
            echo "üîÅ Restarting service: $SERVICE_NAME (sudo -n)"
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would run sudo -n systemctl restart $SERVICE_NAME"
            else
              sudo -n systemctl restart "$SERVICE_NAME" || {
                echo "‚ùå systemctl restart failed. Dumping status and journal"
                sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
                sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
                exit 1
              }
            fi

            # Post-deploy health check
            echo "üîé Running post-deploy health check"
            if check_health; then
              echo "‚úÖ Deployment healthy"
              exit 0
            fi

            # Health failed: attempt rollback if we have a previous commit
            echo "‚ö†Ô∏è Deployment unhealthy. Attempting rollback to previous commit: $PREV_COMMIT"
            if [ -z "$PREV_COMMIT" ]; then
              echo "‚ùå No previous commit available to rollback to. Dumping diagnostics and aborting."
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            fi

            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would rollback to $PREV_COMMIT and restart"
              exit 1
            fi

            # Perform rollback
            git reset --hard "$PREV_COMMIT" --quiet || {
              echo "‚ùå git reset to previous commit failed"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            }

            # If requirements changed during failed deploy, try restoring previous deps
            if [ "$NEED_PIP_INSTALL" = "true" ] && [ -f "requirements.txt" ]; then
              echo "üì• Restoring dependencies for previous commit"
              pip install --upgrade pip setuptools wheel || true
              pip install -r requirements.txt || true
            fi

            echo "üîÅ Restarting service after rollback"
            sudo -n systemctl restart "$SERVICE_NAME" || {
              echo "‚ùå systemctl restart after rollback failed - dump diagnostics"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            }

            echo "üîé Running health check after rollback"
            if check_health; then
              echo "‚úÖ Rollback succeeded; service restored to previous commit $PREV_COMMIT"
              exit 0
            else
              echo "‚ùå Rollback failed; service still unhealthy. Dumping final diagnostics"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 500 --no-pager || true
              exit 1
            fi
