name: Deploy LUXit.app to VPS (main only)

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to VPS
        env:
          # Repo secrets (ensure these exist in repository Secrets)
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          # VPS connection
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          # Optional overrides; change if your server uses different paths/names
          APP_DIR: /opt/luxit
          SERVICE_NAME: lux-marketing.service
          CANONICAL_HOST: luxit.app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            # Hardened remote deploy script
            set -euxo pipefail

            # Export important env into the remote session (do NOT echo secrets)
            export DATABASE_URL="${DATABASE_URL:-}"
            export SESSION_SECRET="${SESSION_SECRET:-}"
            export CANONICAL_HOST="${CANONICAL_HOST:-luxit.app}"
            export APP_DIR="${APP_DIR:-/opt/luxit}"
            export SERVICE_NAME="${SERVICE_NAME:-lux-marketing.service}"

            # Local deploy defaults (can be overridden by exported env)
            VENV_PATH="${VENV_PATH:-venv}"
            HEALTH_URL="${HEALTH_URL:-http://127.0.0.1:5000/}"
            HEALTH_RETRIES="${HEALTH_RETRIES:-6}"
            HEALTH_INTERVAL="${HEALTH_INTERVAL:-5}"   # seconds
            DRY_RUN="${DRY_RUN:-false}"

            echo "üì¶ Deploy started: user=$(whoami) host=$(hostname) APP_DIR=${APP_DIR}"
            echo "üîí DRY_RUN=${DRY_RUN}"

            # Simple concurrency protection
            LOCKFILE="/tmp/deploy_${SERVICE_NAME}.lock"
            if [ -e "$LOCKFILE" ]; then
              echo "‚ùå Deploy lock present ($LOCKFILE). Another deploy may be running. Aborting."
              exit 1
            fi
            trap 'rm -f "$LOCKFILE"' EXIT
            touch "$LOCKFILE"

            # Check required commands
            for cmd in git python3 systemctl; do
              if ! command -v "$cmd" >/dev/null 2>&1; then
                echo "‚ùå Required command not found: $cmd"
                exit 1
              fi
            done

            if command -v curl >/dev/null 2>&1; then
              HAVE_CURL=true
            else
              HAVE_CURL=false
              echo "‚ö†Ô∏è curl not found; health checks will be skipped"
            fi

            # Ensure app directory exists
            if [ ! -d "$APP_DIR" ]; then
              echo "‚ùå App directory not found: $APP_DIR"
              ls -la "$(dirname "$APP_DIR")" || true
              exit 1
            fi
            cd "$APP_DIR"

            # Avoid dubious ownership error (idempotent)
            git config --global --add "safe.directory" "$APP_DIR" || true

            # Record previous commit for rollback
            PREV_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || true)"
            echo "üîÅ Previous commit: ${PREV_COMMIT:-<none>}"

            # Fetch and update to origin/main (fallback to FETCH_HEAD)
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would fetch and reset to origin/main"
            else
              git fetch origin main --quiet || true

              if git show-ref --verify --quiet "refs/remotes/origin/main"; then
                git checkout main --quiet || git checkout -B main --quiet
                git reset --hard origin/main --quiet
              else
                HASH=$(git rev-parse --verify FETCH_HEAD 2>/dev/null || true)
                if [ -n "$HASH" ]; then
                  git checkout -B main "$HASH" --quiet
                  git reset --hard "$HASH" --quiet
                else
                  git fetch origin --quiet || true
                  git checkout -B main origin/main --quiet || true
                  git reset --hard origin/main --quiet || true
                fi
              fi
            fi

            # Prefer SSH for future remote operations
            git remote set-url origin git@github.com:ldshawver/LUXit.app.git || true

            NEW_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || true)"
            echo "‚úÖ New commit: ${NEW_COMMIT:-<none>}"
            git --no-pager log -1 --oneline || true
            ls -la

            # Virtualenv activation
            if [ ! -f "${VENV_PATH}/bin/activate" ]; then
              echo "‚ùå virtualenv not found at ${VENV_PATH}/bin/activate"
              exit 1
            fi
            # shellcheck disable=SC1091
            source "${VENV_PATH}/bin/activate"

            # Determine if requirements changed (or first deploy)
            NEED_PIP_INSTALL=false
            if [ -n "$PREV_COMMIT" ] && [ -n "$NEW_COMMIT" ] && [ "$PREV_COMMIT" != "$NEW_COMMIT" ]; then
              if git diff --name-only "$PREV_COMMIT" "$NEW_COMMIT" | grep -q -E '^requirements(\.txt)?$'; then
                NEED_PIP_INSTALL=true
              fi
            fi
            if [ -z "$PREV_COMMIT" ]; then
              NEED_PIP_INSTALL=true
            fi

            if [ "$NEED_PIP_INSTALL" = "true" ]; then
              echo "üì• Installing/upgrading dependencies (pip)"
              if [ "$DRY_RUN" != "true" ] && [ -f "requirements.txt" ]; then
                pip install --upgrade pip setuptools wheel || true
                pip install -r requirements.txt
              fi
            else
              echo "‚ÑπÔ∏è requirements.txt unchanged; skipping pip install"
            fi

            # Python compile check (quick sanity)
            echo "üß™ Running Python compile checks"
            if [ "$DRY_RUN" != "true" ]; then
              python3 -m py_compile app.py || {
                echo "‚ùå Python syntax check failed"
                exit 1
              }
            fi

            # Health check function (explicit seconds)
            check_health() {
              if [ "${HAVE_CURL}" != "true" ]; then
                echo "‚ö†Ô∏è curl not available; skipping health check"
                return 0
              fi
              local i=0
              while [ $i -lt "$HEALTH_RETRIES" ]; do
                if timeout "${HEALTH_INTERVAL}s" curl -sSf "$HEALTH_URL" >/dev/null 2>&1; then
                  echo "‚úÖ Health check OK (attempt $((i+1)))"
                  return 0
                fi
                echo "‚è≥ Health check attempt $((i+1)) failed; waiting ${HEALTH_INTERVAL}s before retry"
                i=$((i+1))
                sleep "$HEALTH_INTERVAL"
              done
              echo "‚ùå Health check failed after $HEALTH_RETRIES attempts"
              return 1
            }

            # Restart service (ensure deploy user has passwordless sudo for systemctl if running non-root)
            echo "üîÅ Restarting service: $SERVICE_NAME"
            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would run sudo -n systemctl restart $SERVICE_NAME"
            else
              sudo -n systemctl daemon-reload || true
              sudo -n systemctl restart "$SERVICE_NAME" || {
                echo "‚ùå systemctl restart failed. Dumping status and journal"
                sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
                sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
                exit 1
              }
            fi

            # Post-deploy health check
            echo "üîé Running post-deploy health check"
            if check_health; then
              echo "‚úÖ Deployment healthy"
              exit 0
            fi

            # Health failed: attempt rollback
            echo "‚ö†Ô∏è Deployment unhealthy. Attempting rollback to previous commit: $PREV_COMMIT"
            if [ -z "$PREV_COMMIT" ]; then
              echo "‚ùå No previous commit available to rollback to. Dumping diagnostics and aborting."
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            fi

            if [ "$DRY_RUN" = "true" ]; then
              echo "DRY-RUN: would rollback to $PREV_COMMIT and restart"
              exit 1
            fi

            git reset --hard "$PREV_COMMIT" --quiet || {
              echo "‚ùå git reset to previous commit failed"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            }

            if [ "$NEED_PIP_INSTALL" = "true" ] && [ -f "requirements.txt" ]; then
              echo "üì• Restoring dependencies for previous commit"
              pip install --upgrade pip setuptools wheel || true
              pip install -r requirements.txt || true
            fi

            echo "üîÅ Restarting service after rollback"
            sudo -n systemctl restart "$SERVICE_NAME" || {
              echo "‚ùå systemctl restart after rollback failed - dump diagnostics"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
              exit 1
            }

            echo "üîé Running health check after rollback"
            if check_health; then
              echo "‚úÖ Rollback succeeded; service restored to previous commit $PREV_COMMIT"
              exit 0
            else
              echo "‚ùå Rollback failed; service still unhealthy. Dumping final diagnostics"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
              sudo journalctl -u "${SERVICE_NAME%.*}" -n 500 --no-pager || true
              exit 1
            fi
