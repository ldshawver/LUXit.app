- name: Deploy to VPS
  uses: appleboy/ssh-action@v1.0.3
  with:
    host: ${{ secrets.VPS_HOST }}
    username: ${{ secrets.VPS_USER }}
    key: ${{ secrets.VPS_SSH_KEY }}
    script: |
      # Hardened deploy script with rollback and diagnostics
      set -euxo pipefail

      # Configuration - edit to match your VPS/app
      APP_DIR="/opt/luxit"                      # must match actual repo dir on VPS
      VENV_PATH="venv"
      SERVICE_NAME="lux-marketing.service"      # adjust if different
      HEALTH_URL="http://127.0.0.1:5000/"
      HEALTH_RETRIES=6
      HEALTH_INTERVAL=5
      DRY_RUN="${DRY_RUN:-false}"

      echo "üì¶ Deploy started: user=$(whoami) host=$(hostname) pwd=$(pwd || true)"
      echo "üîí DRY_RUN=$DRY_RUN"

      LOCKFILE="/tmp/deploy_${SERVICE_NAME}.lock"
      if [ -e "$LOCKFILE" ]; then
        echo "‚ùå Deploy lock present ($LOCKFILE). Aborting."
        exit 1
      fi
      trap 'rm -f "$LOCKFILE"' EXIT
      touch "$LOCKFILE"

      for cmd in git python3 systemctl; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
          echo "‚ùå Required command not found: $cmd"
          exit 1
        fi
      done

      if ! command -v curl >/dev/null 2>&1; then
        echo "‚ö†Ô∏è curl not found; health checks will be skipped"
        HAVE_CURL=false
      else
        HAVE_CURL=true
      fi

      if [ ! -d "$APP_DIR" ]; then
        echo "‚ùå App directory not found: $APP_DIR"
        ls -la "$(dirname "$APP_DIR")" || true
        exit 1
      fi
      cd "$APP_DIR"

      # Avoid dubious ownership error for this directory (idempotent)
      git config --global --add safe.directory "$APP_DIR" || true

      PREV_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || true)"
      echo "üîÅ Previous commit: ${PREV_COMMIT:-<none>}"

      if [ "$DRY_RUN" = "true" ]; then
        echo "DRY-RUN: would fetch and reset to origin/main"
      else
        # fetch the branch (quiet by default)
        git fetch origin main --quiet || true

        # If remote tracking branch exists, reset to it. Otherwise use FETCH_HEAD safely.
        if git show-ref --verify --quiet "refs/remotes/origin/main"; then
          git checkout main --quiet || git checkout -B main --quiet
          git reset --hard origin/main --quiet
        else
          # fallback: use FETCH_HEAD commit hash explicitly to avoid ambiguous name errors
          HASH=$(git rev-parse --verify FETCH_HEAD 2>/dev/null || true)
          if [ -n "$HASH" ]; then
            git checkout -B main "$HASH" --quiet
            git reset --hard "$HASH" --quiet
          else
            # try a full fetch and then checkout origin/main
            git fetch origin --quiet
            git checkout -B main origin/main --quiet || true
            git reset --hard origin/main --quiet || true
          fi
        fi
      fi

      # Ensure future remote operations use SSH (so the server can use its SSH key)
      git remote set-url origin git@github.com:ldshawver/LUXit.app.git || true

      NEW_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || true)"
      echo "‚úÖ New commit: ${NEW_COMMIT:-<none>}"

      git --no-pager log -1 --oneline || true
      ls -la

      if [ ! -f "${VENV_PATH}/bin/activate" ]; then
        echo "‚ùå virtualenv not found at ${VENV_PATH}/bin/activate"
        exit 1
      fi
      # shellcheck disable=SC1091
      source "${VENV_PATH}/bin/activate"

      NEED_PIP_INSTALL=false
      if [ -n "$PREV_COMMIT" ] && [ -n "$NEW_COMMIT" ] && [ "$PREV_COMMIT" != "$NEW_COMMIT" ]; then
        if git diff --name-only "$PREV_COMMIT" "$NEW_COMMIT" | grep -q -E '^requirements(\.txt)?$'; then
          NEED_PIP_INSTALL=true
        fi
      fi
      if [ -z "$PREV_COMMIT" ]; then
        NEED_PIP_INSTALL=true
      fi

      if [ "$NEED_PIP_INSTALL" = "true" ]; then
        echo "üì• Installing/upgrading dependencies (pip)"
        if [ "$DRY_RUN" != "true" ] && [ -f "requirements.txt" ]; then
          pip install --upgrade pip setuptools wheel || true
          pip install -r requirements.txt
        fi
      else
        echo "‚ÑπÔ∏è requirements.txt unchanged; skipping pip install"
      fi

      echo "üß™ Running Python compile checks"
      if [ "$DRY_RUN" != "true" ]; then
        python3 -m py_compile app.py || { echo "‚ùå Python syntax check failed"; exit 1; }
      fi

      check_health() {
        if [ "$HAVE_CURL" = "false" ]; then
          echo "‚ö†Ô∏è curl not available; skipping health check"
          return 0
        fi
        local i=0
        while [ $i -lt "$HEALTH_RETRIES" ]; do
          if timeout $HEALTH_INTERVAL curl -sSf "$HEALTH_URL" >/dev/null 2>&1; then
            echo "‚úÖ Health check OK (attempt $((i+1)))"
            return 0
          fi
          echo "‚è≥ Health check attempt $((i+1)) failed; waiting $HEALTH_INTERVALs"
          i=$((i+1))
          sleep "$HEALTH_INTERVAL"
        done
        echo "‚ùå Health check failed"
        return 1
      }

      echo "üîÅ Restarting service: $SERVICE_NAME"
      if [ "$DRY_RUN" = "true" ]; then
        echo "DRY-RUN: would run sudo -n systemctl restart $SERVICE_NAME"
      else
        sudo -n systemctl restart "$SERVICE_NAME" || {
          echo "‚ùå systemctl restart failed. Dumping status and journal"
          sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
          sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
          exit 1
        }
      fi

      echo "üîé Running post-deploy health check"
      if check_health; then
        echo "‚úÖ Deployment healthy"
        exit 0
      fi

      echo "‚ö†Ô∏è Deployment unhealthy. Attempting rollback to previous commit: $PREV_COMMIT"
      if [ -z "$PREV_COMMIT" ]; then
        echo "‚ùå No previous commit available to rollback to. Dumping diagnostics and aborting."
        sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
        sudo journalctl -u "${SERVICE_NAME%.*}" -n 200 --no-pager || true
        exit 1
      fi

      if [ "$DRY_RUN" = "true" ]; then
        echo "DRY-RUN: would rollback to $PREV_COMMIT and restart"
        exit 1
      fi

      git reset --hard "$PREV_COMMIT" --quiet || {
        echo "‚ùå git reset to previous commit failed"
        sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
        sudo journalctl -u "${SERVICE_NAME%](#)
ÓÄÄ
